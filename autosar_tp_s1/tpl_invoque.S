/**
 * @file tpl_invoque.S
 *
 * @section descr File description
 *
 * System call user level invoque API.
 *
 * @warning this file is generated by gen_invoque.sh based on the 
 * tpl_os_service_ids.h header file.
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005+
 * Copyright ESEO for function and data structures documentation and ARM port
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $$Date$$
 * $$Rev$$
 * $$Author$$
 * $$URL$$
 */
#include "tpl_os_application_def.h"
#include "tpl_service_ids.h"

#if WITH_SYSTEM_CALL == NO
#error "This file should not be part of your project since WITH_SYSTEM_CALL is not defined"
#endif


#if WITH_MEMMAP == NO

#endif /* WITH_MEMMAP == NO */

#define API_START_SEC_CODE
#include "tpl_as_memmap.h"

	.syntax unified
	.thumb
	.extern nested_kernel_entrance_counter

	/* 
	 * Service GetActiveApplicationMode
	 */
	.global GetActiveApplicationMode
	.type   GetActiveApplicationMode, %function
GetActiveApplicationMode:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetActiveApplicationMode_direct_call
	/* Exception call to the service : use SVC exception */
GetActiveApplicationMode_exception_call:
	mov r3,#OSServiceId_GetActiveApplicationMode
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetActiveApplicationMode
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetActiveApplicationMode_exit_call
	/* Procedural call to the service */
GetActiveApplicationMode_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetActiveApplicationMode<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetActiveApplicationMode_exit_call:
	bx lr
	/* 
	 * Service StartOS
	 */
	.global tpl_start_os
	.type   tpl_start_os, %function
tpl_start_os:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StartOS_direct_call
	/* Exception call to the service : use SVC exception */
StartOS_exception_call:
	mov r3,#OSServiceId_StartOS
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_StartOS
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b StartOS_exit_call
	/* Procedural call to the service */
StartOS_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StartOS<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
StartOS_exit_call:
	bx lr
	/* 
	 * Service ShutdownOS
	 */
	.global ShutdownOS
	.type   ShutdownOS, %function
ShutdownOS:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ShutdownOS_direct_call
	/* Exception call to the service : use SVC exception */
ShutdownOS_exception_call:
	mov r3,#OSServiceId_ShutdownOS
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ShutdownOS
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ShutdownOS_exit_call
	/* Procedural call to the service */
ShutdownOS_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ShutdownOS<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ShutdownOS_exit_call:
	bx lr
	/* 
	 * Service EnableAllInterrupts
	 */
	.global EnableAllInterrupts
	.type   EnableAllInterrupts, %function
EnableAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq EnableAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
EnableAllInterrupts_exception_call:
	mov r3,#OSServiceId_EnableAllInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_EnableAllInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b EnableAllInterrupts_exit_call
	/* Procedural call to the service */
EnableAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_EnableAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
EnableAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service DisableAllInterrupts
	 */
	.global DisableAllInterrupts
	.type   DisableAllInterrupts, %function
DisableAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq DisableAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
DisableAllInterrupts_exception_call:
	mov r3,#OSServiceId_DisableAllInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_DisableAllInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b DisableAllInterrupts_exit_call
	/* Procedural call to the service */
DisableAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_DisableAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
DisableAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service ResumeAllInterrupts
	 */
	.global ResumeAllInterrupts
	.type   ResumeAllInterrupts, %function
ResumeAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ResumeAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
ResumeAllInterrupts_exception_call:
	mov r3,#OSServiceId_ResumeAllInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ResumeAllInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ResumeAllInterrupts_exit_call
	/* Procedural call to the service */
ResumeAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ResumeAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ResumeAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service SuspendAllInterrupts
	 */
	.global SuspendAllInterrupts
	.type   SuspendAllInterrupts, %function
SuspendAllInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SuspendAllInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
SuspendAllInterrupts_exception_call:
	mov r3,#OSServiceId_SuspendAllInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_SuspendAllInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b SuspendAllInterrupts_exit_call
	/* Procedural call to the service */
SuspendAllInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SuspendAllInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
SuspendAllInterrupts_exit_call:
	bx lr
	/* 
	 * Service ResumeOSInterrupts
	 */
	.global ResumeOSInterrupts
	.type   ResumeOSInterrupts, %function
ResumeOSInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ResumeOSInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
ResumeOSInterrupts_exception_call:
	mov r3,#OSServiceId_ResumeOSInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ResumeOSInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ResumeOSInterrupts_exit_call
	/* Procedural call to the service */
ResumeOSInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ResumeOSInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ResumeOSInterrupts_exit_call:
	bx lr
	/* 
	 * Service SuspendOSInterrupts
	 */
	.global SuspendOSInterrupts
	.type   SuspendOSInterrupts, %function
SuspendOSInterrupts:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SuspendOSInterrupts_direct_call
	/* Exception call to the service : use SVC exception */
SuspendOSInterrupts_exception_call:
	mov r3,#OSServiceId_SuspendOSInterrupts
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_SuspendOSInterrupts
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b SuspendOSInterrupts_exit_call
	/* Procedural call to the service */
SuspendOSInterrupts_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SuspendOSInterrupts<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
SuspendOSInterrupts_exit_call:
	bx lr
	/* 
	 * Service CallTerminateISR2
	 */
	.global CallTerminateISR2
	.type   CallTerminateISR2, %function
CallTerminateISR2:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq CallTerminateISR2_direct_call
	/* Exception call to the service : use SVC exception */
CallTerminateISR2_exception_call:
	mov r3,#OSServiceId_CallTerminateISR2
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_CallTerminateISR2
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b CallTerminateISR2_exit_call
	/* Procedural call to the service */
CallTerminateISR2_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_CallTerminateISR2<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
CallTerminateISR2_exit_call:
	bx lr
	/* 
	 * Service ActivateTask
	 */
	.global ActivateTask
	.type   ActivateTask, %function
ActivateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ActivateTask_direct_call
	/* Exception call to the service : use SVC exception */
ActivateTask_exception_call:
	mov r3,#OSServiceId_ActivateTask
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ActivateTask
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ActivateTask_exit_call
	/* Procedural call to the service */
ActivateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ActivateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ActivateTask_exit_call:
	bx lr
	/* 
	 * Service TerminateTask
	 */
	.global TerminateTask
	.type   TerminateTask, %function
TerminateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq TerminateTask_direct_call
	/* Exception call to the service : use SVC exception */
TerminateTask_exception_call:
	mov r3,#OSServiceId_TerminateTask
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_TerminateTask
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b TerminateTask_exit_call
	/* Procedural call to the service */
TerminateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_TerminateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
TerminateTask_exit_call:
	bx lr
	/* 
	 * Service ChainTask
	 */
	.global ChainTask
	.type   ChainTask, %function
ChainTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ChainTask_direct_call
	/* Exception call to the service : use SVC exception */
ChainTask_exception_call:
	mov r3,#OSServiceId_ChainTask
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ChainTask
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ChainTask_exit_call
	/* Procedural call to the service */
ChainTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ChainTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ChainTask_exit_call:
	bx lr
	/* 
	 * Service Schedule
	 */
	.global Schedule
	.type   Schedule, %function
Schedule:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq Schedule_direct_call
	/* Exception call to the service : use SVC exception */
Schedule_exception_call:
	mov r3,#OSServiceId_Schedule
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_Schedule
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b Schedule_exit_call
	/* Procedural call to the service */
Schedule_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_Schedule<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
Schedule_exit_call:
	bx lr
	/* 
	 * Service GetTaskID
	 */
	.global GetTaskID
	.type   GetTaskID, %function
GetTaskID:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetTaskID_direct_call
	/* Exception call to the service : use SVC exception */
GetTaskID_exception_call:
	mov r3,#OSServiceId_GetTaskID
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetTaskID
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetTaskID_exit_call
	/* Procedural call to the service */
GetTaskID_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetTaskID<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetTaskID_exit_call:
	bx lr
	/* 
	 * Service GetTaskState
	 */
	.global GetTaskState
	.type   GetTaskState, %function
GetTaskState:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetTaskState_direct_call
	/* Exception call to the service : use SVC exception */
GetTaskState_exception_call:
	mov r3,#OSServiceId_GetTaskState
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetTaskState
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetTaskState_exit_call
	/* Procedural call to the service */
GetTaskState_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetTaskState<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetTaskState_exit_call:
	bx lr
	/* 
	 * Service CallTerminateTask
	 */
	.global CallTerminateTask
	.type   CallTerminateTask, %function
CallTerminateTask:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq CallTerminateTask_direct_call
	/* Exception call to the service : use SVC exception */
CallTerminateTask_exception_call:
	mov r3,#OSServiceId_CallTerminateTask
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_CallTerminateTask
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b CallTerminateTask_exit_call
	/* Procedural call to the service */
CallTerminateTask_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_CallTerminateTask<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
CallTerminateTask_exit_call:
	bx lr
	/* 
	 * Service GetResource
	 */
	.global GetResource
	.type   GetResource, %function
GetResource:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetResource_direct_call
	/* Exception call to the service : use SVC exception */
GetResource_exception_call:
	mov r3,#OSServiceId_GetResource
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetResource
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetResource_exit_call
	/* Procedural call to the service */
GetResource_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetResource<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetResource_exit_call:
	bx lr
	/* 
	 * Service ReleaseResource
	 */
	.global ReleaseResource
	.type   ReleaseResource, %function
ReleaseResource:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq ReleaseResource_direct_call
	/* Exception call to the service : use SVC exception */
ReleaseResource_exception_call:
	mov r3,#OSServiceId_ReleaseResource
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_ReleaseResource
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b ReleaseResource_exit_call
	/* Procedural call to the service */
ReleaseResource_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_ReleaseResource<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
ReleaseResource_exit_call:
	bx lr
	/* 
	 * Service IncrementCounter
	 */
	.global IncrementCounter
	.type   IncrementCounter, %function
IncrementCounter:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq IncrementCounter_direct_call
	/* Exception call to the service : use SVC exception */
IncrementCounter_exception_call:
	mov r3,#OSServiceId_IncrementCounter
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_IncrementCounter
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b IncrementCounter_exit_call
	/* Procedural call to the service */
IncrementCounter_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_IncrementCounter<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
IncrementCounter_exit_call:
	bx lr
	/* 
	 * Service GetCounterValue
	 */
	.global GetCounterValue
	.type   GetCounterValue, %function
GetCounterValue:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetCounterValue_direct_call
	/* Exception call to the service : use SVC exception */
GetCounterValue_exception_call:
	mov r3,#OSServiceId_GetCounterValue
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetCounterValue
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetCounterValue_exit_call
	/* Procedural call to the service */
GetCounterValue_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetCounterValue<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetCounterValue_exit_call:
	bx lr
	/* 
	 * Service GetElapsedCounterValue
	 */
	.global GetElapsedCounterValue
	.type   GetElapsedCounterValue, %function
GetElapsedCounterValue:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetElapsedCounterValue_direct_call
	/* Exception call to the service : use SVC exception */
GetElapsedCounterValue_exception_call:
	mov r3,#OSServiceId_GetElapsedCounterValue
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetElapsedCounterValue
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetElapsedCounterValue_exit_call
	/* Procedural call to the service */
GetElapsedCounterValue_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetElapsedCounterValue<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetElapsedCounterValue_exit_call:
	bx lr
	/* 
	 * Service StartScheduleTableRel
	 */
	.global StartScheduleTableRel
	.type   StartScheduleTableRel, %function
StartScheduleTableRel:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StartScheduleTableRel_direct_call
	/* Exception call to the service : use SVC exception */
StartScheduleTableRel_exception_call:
	mov r3,#OSServiceId_StartScheduleTableRel
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_StartScheduleTableRel
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b StartScheduleTableRel_exit_call
	/* Procedural call to the service */
StartScheduleTableRel_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StartScheduleTableRel<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
StartScheduleTableRel_exit_call:
	bx lr
	/* 
	 * Service StartScheduleTableAbs
	 */
	.global StartScheduleTableAbs
	.type   StartScheduleTableAbs, %function
StartScheduleTableAbs:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StartScheduleTableAbs_direct_call
	/* Exception call to the service : use SVC exception */
StartScheduleTableAbs_exception_call:
	mov r3,#OSServiceId_StartScheduleTableAbs
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_StartScheduleTableAbs
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b StartScheduleTableAbs_exit_call
	/* Procedural call to the service */
StartScheduleTableAbs_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StartScheduleTableAbs<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
StartScheduleTableAbs_exit_call:
	bx lr
	/* 
	 * Service StopScheduleTable
	 */
	.global StopScheduleTable
	.type   StopScheduleTable, %function
StopScheduleTable:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StopScheduleTable_direct_call
	/* Exception call to the service : use SVC exception */
StopScheduleTable_exception_call:
	mov r3,#OSServiceId_StopScheduleTable
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_StopScheduleTable
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b StopScheduleTable_exit_call
	/* Procedural call to the service */
StopScheduleTable_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StopScheduleTable<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
StopScheduleTable_exit_call:
	bx lr
	/* 
	 * Service NextScheduleTable
	 */
	.global NextScheduleTable
	.type   NextScheduleTable, %function
NextScheduleTable:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq NextScheduleTable_direct_call
	/* Exception call to the service : use SVC exception */
NextScheduleTable_exception_call:
	mov r3,#OSServiceId_NextScheduleTable
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_NextScheduleTable
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b NextScheduleTable_exit_call
	/* Procedural call to the service */
NextScheduleTable_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_NextScheduleTable<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
NextScheduleTable_exit_call:
	bx lr
	/* 
	 * Service GetScheduleTableStatus
	 */
	.global GetScheduleTableStatus
	.type   GetScheduleTableStatus, %function
GetScheduleTableStatus:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetScheduleTableStatus_direct_call
	/* Exception call to the service : use SVC exception */
GetScheduleTableStatus_exception_call:
	mov r3,#OSServiceId_GetScheduleTableStatus
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetScheduleTableStatus
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetScheduleTableStatus_exit_call
	/* Procedural call to the service */
GetScheduleTableStatus_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetScheduleTableStatus<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetScheduleTableStatus_exit_call:
	bx lr
	/* 
	 * Service GetISRID
	 */
	.global GetISRID
	.type   GetISRID, %function
GetISRID:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq GetISRID_direct_call
	/* Exception call to the service : use SVC exception */
GetISRID_exception_call:
	mov r3,#OSServiceId_GetISRID
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_GetISRID
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b GetISRID_exit_call
	/* Procedural call to the service */
GetISRID_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_GetISRID<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
GetISRID_exit_call:
	bx lr
	/* 
	 * Service StartScheduleTableSynchron
	 */
	.global StartScheduleTableSynchron
	.type   StartScheduleTableSynchron, %function
StartScheduleTableSynchron:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq StartScheduleTableSynchron_direct_call
	/* Exception call to the service : use SVC exception */
StartScheduleTableSynchron_exception_call:
	mov r3,#OSServiceId_StartScheduleTableSynchron
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_StartScheduleTableSynchron
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b StartScheduleTableSynchron_exit_call
	/* Procedural call to the service */
StartScheduleTableSynchron_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_StartScheduleTableSynchron<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
StartScheduleTableSynchron_exit_call:
	bx lr
	/* 
	 * Service SyncScheduleTable
	 */
	.global SyncScheduleTable
	.type   SyncScheduleTable, %function
SyncScheduleTable:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SyncScheduleTable_direct_call
	/* Exception call to the service : use SVC exception */
SyncScheduleTable_exception_call:
	mov r3,#OSServiceId_SyncScheduleTable
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_SyncScheduleTable
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b SyncScheduleTable_exit_call
	/* Procedural call to the service */
SyncScheduleTable_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SyncScheduleTable<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
SyncScheduleTable_exit_call:
	bx lr
	/* 
	 * Service SetScheduleTableAsync
	 */
	.global SetScheduleTableAsync
	.type   SetScheduleTableAsync, %function
SetScheduleTableAsync:
	/* manage reentrance of kernel */
	ldr r3, =nested_kernel_entrance_counter
	ldr r3, [r3]
	cmp r3,#1 /* If nested_kernel_entrance_counter is greater or equal than 1 */
	          /* then we are in Handler mode and we must call the service with a direct call to the function */
	beq SetScheduleTableAsync_direct_call
	/* Exception call to the service : use SVC exception */
SetScheduleTableAsync_exception_call:
	mov r3,#OSServiceId_SetScheduleTableAsync
  /* Runtime enforcement: save r0 thru r3 (parameters + syscall id) */
  push {r0-r3}
  b slow_task /* slow the task and update the model */
	svc #OSServiceId_SetScheduleTableAsync
  str r0, [sp,#16] /* save the return value  on top of the stack*/
  pop {r0-r3} /* restore the parameters + syscall id */
  b compute_NEFT /* compute the NEFT */
  pop {r0} /* restore r0, the return value of the syscall */
	b SetScheduleTableAsync_exit_call
	/* Procedural call to the service */
SetScheduleTableAsync_direct_call:
	/* get the appropriate system call address into R3 */
	ldr r3, =tpl_dispatch_table
	ldr r3, [r3, #OSServiceId_SetScheduleTableAsync<<2]
	/* call the service  */
	push {lr}
	blx r3
	pop {lr}
	/* Function call */
SetScheduleTableAsync_exit_call:
	bx lr


#define API_STOP_SEC_CODE
#include "tpl_as_memmap.h"


/* End of file tpl_invoque.S */

