/**
 * @file tpl_os.c
 *
 * @section File description
 *
 * This file gathers system call declarations.
 *
 * Generated from application test
 * Automatically generated by goil on Fri Feb 26 00:21:41 2016
 * from root OIL file autosar_tp_s1.oil
 *
 * @section File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_os.h"
#include "tpl_control.h"

#include "tpl_os_os_kernel.h"
#include "tpl_os_os.h"
#include "tpl_os_interrupt_kernel.h"
#include "tpl_os_task_kernel.h"
#include "tpl_os_resource_kernel.h"
#include "tpl_as_counter_kernel.h"
#include "tpl_as_st_kernel.h"
#include "tpl_as_isr_kernel.h"
#include "tpl_as_gt_kernel.h"

/*--------------------------------------------------------------------------*
 * os system calls.
 * corresponding kernel implementation is in files
 * tpl_os_os_kernel.h and tpl_os_os_kernel.c
 * tpl_os_os.h and tpl_os_os.c
 *--------------------------------------------------------------------------*/

/*
 * GetActiveApplicationMode
 *
 * This service returns the current application mode. It may be used to
 * write mode dependent code.
 *
 *
 * Return value:
 * The active application mode
 */
FUNC(AppModeType, OS_CODE) GetActiveApplicationMode(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_GetActiveApplicationMode);

  AppModeType res = tpl_get_active_application_mode_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_GetActiveApplicationMode);
  
  
  return res;
  
}

/*
 * tpl_start_os
 *
 * The user can call this system service to start the operating system in
 * a specific mode.
 *
 * Note: StartOS is provided in tpl_os_os.c.
 *       StartOS calls tpl_start_os.
 *       tpl_start_os should not be called directly by the application
 *
 * mode:  The application mode
 */
FUNC(void, OS_CODE) tpl_start_os(CONST(AppModeType, AUTOMATIC) mode)
{
  
  slow_task( (void*) &mode,NULL,NULL,OSServiceId_StartOS);
tpl_start_os_service(mode);

  compute_NEFT( (void*) &mode,NULL,NULL,OSServiceId_StartOS);
  
  
}

/*
 * ShutdownOS
 *
 * The user can call this system service to abort the overall system (e.g.
 * emergency off). The operating system also calls this function
 * internally, if it has reached an undefined internal state and is no
 * longer ready to run.
 *
 * error:  The error that occured
 */
FUNC(void, OS_CODE) ShutdownOS(CONST(StatusType, AUTOMATIC) error)
{
  
  slow_task( (void*) &error,NULL,NULL,OSServiceId_ShutdownOS);
tpl_shutdown_os_service(error);

  compute_NEFT( (void*) &error,NULL,NULL,OSServiceId_ShutdownOS);
  
  
}

/*--------------------------------------------------------------------------*
 * interrupt system calls.
 * corresponding kernel implementation is in files
 * tpl_os_interrupt_kernel.h and tpl_os_interrupt_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * EnableAllInterrupts
 *
 * This service restores the state saved by DisableAllInterrupts.
 *
 */
FUNC(void, OS_CODE) EnableAllInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_EnableAllInterrupts);
tpl_enable_all_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_EnableAllInterrupts);
  
  
}

/*
 * DisableAllInterrupts
 *
 * This service disables all interrupts for which the hardware supports
 * disabling. The state before is saved for the EnableAllInterrupts call.
 *
 */
FUNC(void, OS_CODE) DisableAllInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_DisableAllInterrupts);
tpl_disable_all_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_DisableAllInterrupts);
  
  
}

/*
 * ResumeAllInterrupts
 *
 * This service restores the recognition status of all interrupts saved by
 * the SuspendAllInterrupts service.
 *
 */
FUNC(void, OS_CODE) ResumeAllInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_ResumeAllInterrupts);
tpl_resume_all_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_ResumeAllInterrupts);
  
  
}

/*
 * SuspendAllInterrupts
 *
 * This service saves the recognition status of all interrupts and
 * disables all interrupts for which the hardware supports disabling.
 *
 */
FUNC(void, OS_CODE) SuspendAllInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_SuspendAllInterrupts);
tpl_suspend_all_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_SuspendAllInterrupts);
  
  
}

/*
 * ResumeOSInterrupts
 *
 * This service restores the recognition status of interrupts saved by the
 * SuspendOSInterrupts service.
 *
 */
FUNC(void, OS_CODE) ResumeOSInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_ResumeOSInterrupts);
tpl_resume_os_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_ResumeOSInterrupts);
  
  
}

/*
 * SuspendOSInterrupts
 *
 * This service saves the recognition status of interrupts of category 2
 * and disables the recognition of these interrupts.
 *
 */
FUNC(void, OS_CODE) SuspendOSInterrupts(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_SuspendOSInterrupts);
tpl_suspend_os_interrupts_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_SuspendOSInterrupts);
  
  
}

/*
 * CallTerminateISR2
 *
 * 
 *
 */
FUNC(void, OS_CODE) CallTerminateISR2(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_CallTerminateISR2);
tpl_call_terminate_isr2_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_CallTerminateISR2);
  
  
}

/*--------------------------------------------------------------------------*
 * task system calls.
 * corresponding kernel implementation is in files
 * tpl_os_task_kernel.h and tpl_os_task_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * ActivateTask
 *
 * Activate a task
 *
 * task_id:  The identifier of the task to activate
 *
 * Return value:
 * E_OK:       No error (Standard & Extended)
 * E_OS_LIMIT: Too many activations of <task_id> (Standard & Extended)
 * E_OS_ID:    <task_id> is invalid (Extended)
 */
FUNC(StatusType, OS_CODE) ActivateTask(CONST(TaskType, AUTOMATIC) task_id)
{
  
  slow_task( (void*) &task_id,NULL,NULL,OSServiceId_ActivateTask);

  StatusType res = tpl_activate_task_service(task_id);

  compute_NEFT( (void*) &task_id,NULL,NULL,OSServiceId_ActivateTask);
  
  
  return res;
  
}

/*
 * TerminateTask
 *
 * Terminate the calling task
 *
 *
 * Return value:
 * E_OS_RESOURCE: The calling task still occupies a resource (Extended)
 * E_OS_CALLEVEL: Call at interrupt level (Extended)
 */
FUNC(StatusType, OS_CODE) TerminateTask(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_TerminateTask);

  StatusType res = tpl_terminate_task_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_TerminateTask);
  
  
  return res;
  
}

/*
 * ChainTask
 *
 * Terminate the calling task and activate task task_id
 *
 * task_id:  The identifier of the task to chain to
 *
 * Return value:
 * E_OS_LIMIT:    Too many activations of <task_id> (Standard & Extended)
 * E_OS_ID:       <task_id> is invalid (Extended)
 * E_OS_RESOURCE: The calling task still occupies a resource (Extended)
 * E_OS_CALLEVEL: Call at interrupt level (Extended)
 */
FUNC(StatusType, OS_CODE) ChainTask(CONST(TaskType, AUTOMATIC) task_id)
{
  
  slow_task( (void*) &task_id,NULL,NULL,OSServiceId_ChainTask);

  StatusType res = tpl_chain_task_service(task_id);

  compute_NEFT( (void*) &task_id,NULL,NULL,OSServiceId_ChainTask);
  
  
  return res;
  
}

/*
 * Schedule
 *
 * Call the scheduler
 *
 *
 * Return value:
 * E_OK:          No error (Standard & Extended)
 * E_OS_RESOURCE: The calling task still occupies a resource (Extended)
 * E_OS_CALLEVEL: Call at interrupt level (Extended)
 */
FUNC(StatusType, OS_CODE) Schedule(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_Schedule);

  StatusType res = tpl_schedule_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_Schedule);
  
  
  return res;
  
}

/*
 * GetTaskID
 *
 * Get the id of the calling task
 *
 * task_id:  A pointer to the var where the identifier of the task will be
 *           stored
 *
 * Return value:
 * E_OK: No error (Standard & Extended)
 */
FUNC(StatusType, OS_CODE) GetTaskID(VAR(TaskRefType, AUTOMATIC) task_id)
{
  
  slow_task( (void*) &task_id,NULL,NULL,OSServiceId_GetTaskID);

  StatusType res = tpl_get_task_id_service(task_id);

  compute_NEFT( (void*) &task_id,NULL,NULL,OSServiceId_GetTaskID);
  
  
  return res;
  
}

/*
 * GetTaskState
 *
 * Get the task state of a task
 *
 * task_id:  The identifier of the task
 * state:  A pointer to the var where the state of the task will be stored
 *
 * Return value:
 * E_OK:        No error (Standard & Extended)
 * E_OS_ID:     <alarm_id> is invalid (Extended)
 */
FUNC(StatusType, OS_CODE) GetTaskState(CONST(TaskType, AUTOMATIC) task_id,VAR(TaskStateRefType, AUTOMATIC) state)
{
  
  slow_task( (void*) &task_id, (void*) &state,NULL,OSServiceId_GetTaskState);

  StatusType res = tpl_get_task_state_service(task_id, state);

  compute_NEFT( (void*) &task_id, (void*) &state,NULL,OSServiceId_GetTaskState);
  
  
  return res;
  
}

/*
 * CallTerminateTask
 *
 * Used internally as return address of tasks, should not be called by the
 * user
 *
 */
FUNC(void, OS_CODE) CallTerminateTask(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_CallTerminateTask);
tpl_call_terminate_task_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_CallTerminateTask);
  
  
}

/*--------------------------------------------------------------------------*
 * resource system calls.
 * corresponding kernel implementation is in files
 * tpl_os_resource_kernel.h and tpl_os_resource_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * GetResource
 *
 * Get resource res_id. As a result, the priority of the caller may be
 * raised to the priority of the resource if the latter is higher
 *
 * res_id:  The id of the resource to get.
 *
 * Return value:
 * E_OK:    No error (Standard & Extended)
 * E_OS_ID: <res_id> is invalid (Extended)
 */
FUNC(StatusType, OS_CODE) GetResource(CONST(ResourceType, AUTOMATIC) res_id)
{
  
  slow_task( (void*) &res_id,NULL,NULL,OSServiceId_GetResource);

  StatusType res = tpl_get_resource_service(res_id);

  compute_NEFT( (void*) &res_id,NULL,NULL,OSServiceId_GetResource);
  
  
  return res;
  
}

/*
 * ReleaseResource
 *
 * Release resource res_id. The priority of the caller returns to the
 * priority it had before getting the resource
 *
 * res_id:  The id of the resource to release.
 *
 * Return value:
 * E_OK:        No error (Standard & Extended)
 * E_OS_ID:     <res_id> is invalid (Extended)
 * E_OS_ACCESS: Attempt to get a resource which is already occupied by any
 *     task or ISR, or the statically assigned priority of the calling
 *     task or interrupt routine is higher than the calculated ceiling
 *     priority (Extended)
 */
FUNC(StatusType, OS_CODE) ReleaseResource(CONST(ResourceType, AUTOMATIC) res_id)
{
  
  slow_task( (void*) &res_id,NULL,NULL,OSServiceId_ReleaseResource);

  StatusType res = tpl_release_resource_service(res_id);

  compute_NEFT( (void*) &res_id,NULL,NULL,OSServiceId_ReleaseResource);
  
  
  return res;
  
}

/*--------------------------------------------------------------------------*
 * counter system calls.
 * corresponding kernel implementation is in files
 * tpl_as_counter_kernel.h and tpl_as_counter_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * IncrementCounter
 *
 * Increment a counter.
 *
 * counter_id:  identifier of the counter to be incremented
 *
 * Return value:
 * E_OK:    no error (Standard & Extended). Requirements OS286 and OS321
 * E_OS_ID: <counter_id> is not valid (Extended). Requirement OS285
 */
FUNC(StatusType, OS_CODE) IncrementCounter(CONST(CounterType, AUTOMATIC) counter_id)
{
  
  slow_task( (void*) &counter_id,NULL,NULL,OSServiceId_IncrementCounter);

  StatusType res = tpl_increment_counter_service(counter_id);

  compute_NEFT( (void*) &counter_id,NULL,NULL,OSServiceId_IncrementCounter);
  
  
  return res;
  
}

/*
 * GetCounterValue
 *
 * Get the value of a counter.
 *
 * counter_id:  identifier of the counter
 * value:  reference to the variable where is value is returned
 *
 * Return value:
 * E_OK        no error (Standard & Extended). Requirement OS377
 * E_OS_ID     <counter_id> is invalid (Extended). Eequirement OS376
 */
FUNC(StatusType, OS_CODE) GetCounterValue(CONST(CounterType, AUTOMATIC) counter_id,CONST(TickRefType, AUTOMATIC) value)
{
  
  slow_task( (void*) &counter_id, (void*) &value,NULL,OSServiceId_GetCounterValue);

  StatusType res = tpl_get_counter_value_service(counter_id, value);

  compute_NEFT( (void*) &counter_id, (void*) &value,NULL,OSServiceId_GetCounterValue);
  
  
  return res;
  
}

/*
 * GetElapsedCounterValue
 *
 * Get the elapsed value of a counter.
 *
 * counter_id:  identifier of the counter
 * previous_value:  reference to the variable where a previous value is
 *                  stored
 * value:  reference to the variable where is value is returned
 *
 * Return value:
 * E_OK        no error (Standard & Extended). Requirement OS382
 * E_OS_VALUE  the <previous_value> parameter is larger than the
 *     maxallowedvalue of the counter (Standard & Extended). Requirement
 *     OS391
 * E_OS_ID     <counter_id> is invalid (Extended). Eequirement OS381
 */
FUNC(StatusType, OS_CODE) GetElapsedCounterValue(CONST(CounterType, AUTOMATIC) counter_id,CONST(TickRefType, AUTOMATIC) previous_value,CONST(TickRefType, AUTOMATIC) value)
{
  
  slow_task( (void*) &counter_id, (void*) &previous_value, (void*) &value,OSServiceId_GetElapsedCounterValue);

  StatusType res = tpl_get_elapsed_counter_value_service(counter_id, previous_value, value);

  compute_NEFT( (void*) &counter_id, (void*) &previous_value, (void*) &value,OSServiceId_GetElapsedCounterValue);
  
  
  return res;
  
}

/*--------------------------------------------------------------------------*
 * scheduletables system calls.
 * corresponding kernel implementation is in files
 * tpl_as_st_kernel.h and tpl_as_st_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * StartScheduleTableRel
 *
 * Start a schedule table at a relative date.
 *
 * sched_table_id:  identifier of the schedule table to be started.
 * offset:  relative tick value between now and start of the schedule
 *          table.
 *
 * Return value:
 * E_OK:       no error (Standard & Extended). Requirement OS278.
 * E_OS_ID:    <sched_table_id> is not valid (Extended). Requirement
 *     OS275.
 * E_OS_VALUE: <offset> was set to 0 or is greater than the
 *     MAXALLOWEDVALUE of the counter (Standard & Extended). Requirement
 *     OS276 and OS332.
 * E_OS_STATE: the schedule table is already started or currently in state
 *     SCHEDULETABLE_NEXT (Standard & Extended). Requirement OS277.
 */
FUNC(StatusType, OS_CODE) StartScheduleTableRel(CONST(ScheduleTableType, AUTOMATIC) sched_table_id,CONST(TickType, AUTOMATIC) offset)
{
  
  slow_task( (void*) &sched_table_id, (void*) &offset,NULL,OSServiceId_StartScheduleTableRel);

  StatusType res = tpl_start_schedule_table_rel_service(sched_table_id, offset);

  compute_NEFT( (void*) &sched_table_id, (void*) &offset,NULL,OSServiceId_StartScheduleTableRel);
  
  
  return res;
  
}

/*
 * StartScheduleTableAbs
 *
 * Start a schedule table at an absolute date.
 *
 * sched_table_id:  identifier of the schedule table to be started.
 * tick_val:  absolute tick value of the start date of the schedule table.
 *
 * Return value:
 * E_OK:       no error (Standard & Extended). Requirement OS351.
 * E_OS_ID:    <sched_table_id> is not valid (Extended). Requirement
 *     OS348.
 * E_OS_VALUE: <tick_val> is greater than the MAXALLOWEDVALUE of the
 *     counter (Standard & Extended). Requirement OS349.
 * E_OS_STATE: the schedule table is already started or currently in state
 *     SCHEDULETABLE_NEXT (Standard & Extended). Requirement OS350.
 */
FUNC(StatusType, OS_CODE) StartScheduleTableAbs(CONST(ScheduleTableType, AUTOMATIC) sched_table_id,CONST(TickType, AUTOMATIC) tick_val)
{
  
  slow_task( (void*) &sched_table_id, (void*) &tick_val,NULL,OSServiceId_StartScheduleTableAbs);

  StatusType res = tpl_start_schedule_table_abs_service(sched_table_id, tick_val);

  compute_NEFT( (void*) &sched_table_id, (void*) &tick_val,NULL,OSServiceId_StartScheduleTableAbs);
  
  
  return res;
  
}

/*
 * StopScheduleTable
 *
 *  Stop a schedule table.
 *
 * sched_table_id:  identifier of the schedule table to be started.
 *
 * Return value:
 * E_OK:        no error (Standard & Extended). Requirement OS281.
 * E_OS_ID:     <sched_table_id> is not valid (Extended). Requirement
 *     OS279.
 * E_OS_NOFUNC: the schedule table was not started (Standard & Extended).
 *     Requirement OS280.
 */
FUNC(StatusType, OS_CODE) StopScheduleTable(CONST(ScheduleTableType, AUTOMATIC) sched_table_id)
{
  
  slow_task( (void*) &sched_table_id,NULL,NULL,OSServiceId_StopScheduleTable);

  StatusType res = tpl_stop_schedule_table_service(sched_table_id);

  compute_NEFT( (void*) &sched_table_id,NULL,NULL,OSServiceId_StopScheduleTable);
  
  
  return res;
  
}

/*
 * NextScheduleTable
 *
 * Switch the processing from one schedule table to another.
 *
 * current_st_id:  identifier of the schedule table currently in use.
 * next_st_id:  identifier of the next schedule table to process
 *
 * Return value:
 * E_OK:        no error (Standard & Extended). Requirement OS284.
 * E_OS_ID:     <current_sd_id> or <next_sd_id> are not valid (Extended).
 *     Requirement OS282.
 * E_OS_NOFUNC: the schedule table <current_sd_id> is not started or
 *     currently in state SCHEDULETABLE_NEXT (Standard & Extended).
 *     Requirement OS283.
 * E_OS_STATE:  the schedule table <next_sd_id> is already started or
 *     already a next schedule table (Standard & Extended). Requirement
 *     OS309.
 */
FUNC(StatusType, OS_CODE) NextScheduleTable(CONST(ScheduleTableType, AUTOMATIC) current_st_id,CONST(ScheduleTableType, AUTOMATIC) next_st_id)
{
  
  slow_task( (void*) &current_st_id, (void*) &next_st_id,NULL,OSServiceId_NextScheduleTable);

  StatusType res = tpl_next_schedule_table_service(current_st_id, next_st_id);

  compute_NEFT( (void*) &current_st_id, (void*) &next_st_id,NULL,OSServiceId_NextScheduleTable);
  
  
  return res;
  
}

/*
 * GetScheduleTableStatus
 *
 * Get the status of a schedule table
 *
 * sched_table_id:  identifier of the schedule table.
 * status:  reference to a variable where the status is returned.
 *
 * Return value:
 * E_OK:        no error (Standard & Extended). Requirements OS289, OS353,
 *     OS354, OS290 and OS291.
 * E_OS_ID:     <sched_table_id> is not valid (Extended). Requirement
 *     OS293.
 */
FUNC(StatusType, OS_CODE) GetScheduleTableStatus(CONST(ScheduleTableType, AUTOMATIC) sched_table_id,CONST(ScheduleTableStatusRefType, AUTOMATIC) status)
{
  
  slow_task( (void*) &sched_table_id, (void*) &status,NULL,OSServiceId_GetScheduleTableStatus);

  StatusType res = tpl_get_schedule_table_status_service(sched_table_id, status);

  compute_NEFT( (void*) &sched_table_id, (void*) &status,NULL,OSServiceId_GetScheduleTableStatus);
  
  
  return res;
  
}

/*--------------------------------------------------------------------------*
 * isrs system calls.
 * corresponding kernel implementation is in files
 * tpl_as_isr_kernel.h and tpl_as_isr_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * GetISRID
 *
 * Get the ID of the currently running ISR.
 *
 *
 * Return value:
 * Identifier of the currently running ISR or INVALID_ISR when called from
 *     outside a running ISR.
 */
FUNC(ISRType, OS_CODE) GetISRID(void)
{
  
  slow_task(NULL,NULL,NULL,OSServiceId_GetISRID);

  ISRType res = tpl_get_isr_id_service();

  compute_NEFT(NULL,NULL,NULL,OSServiceId_GetISRID);
  
  
  return res;
  
}

/*--------------------------------------------------------------------------*
 * globaltime system calls.
 * corresponding kernel implementation is in files
 * tpl_as_gt_kernel.h and tpl_as_gt_kernel.c
 *--------------------------------------------------------------------------*/

/*
 * StartScheduleTableSynchron
 *
 * Start a schedule table synchronized with global time.
 *
 * sched_table_id:  identifier of the schedule table to be started.
 *
 * Return value:
 * E_OK:       No error.
 * E_OS_ID:    invalid schedule table id, or the schedule table is not
 *     configured as explicitly synchronized.
 * E_OS_STATE: the schedule table is already started
 */
FUNC(StatusType, OS_CODE) StartScheduleTableSynchron(CONST(ScheduleTableType, AUTOMATIC) sched_table_id)
{
  
  slow_task( (void*) &sched_table_id,NULL,NULL,OSServiceId_StartScheduleTableSynchron);

  StatusType res = tpl_start_schedule_table_synchron_service(sched_table_id);

  compute_NEFT( (void*) &sched_table_id,NULL,NULL,OSServiceId_StartScheduleTableSynchron);
  
  
  return res;
  
}

/*
 * SyncScheduleTable
 *
 * Synchronize a schedule table with global time.
 *
 * sched_table_id:  Identifier of the schedule table.
 * value:  Current value of the synchronization counter.
 *
 * Return value:
 * E_OK:       No error.
 * E_OS_STATE: The schedule table is not waiting or running.
 * E_OS_ID:    Invalid schedule table id, or the schedule table is not
 *     configured as explicitly synchronized.
 */
FUNC(StatusType, OS_CODE) SyncScheduleTable(CONST(ScheduleTableType, AUTOMATIC) sched_table_id,CONST(TickType, AUTOMATIC) value)
{
  
  slow_task( (void*) &sched_table_id, (void*) &value,NULL,OSServiceId_SyncScheduleTable);

  StatusType res = tpl_sync_schedule_table_service(sched_table_id, value);

  compute_NEFT( (void*) &sched_table_id, (void*) &value,NULL,OSServiceId_SyncScheduleTable);
  
  
  return res;
  
}

/*
 * SetScheduleTableAsync
 *
 * Set a schedule table asynchronous to global time.
 *
 * sched_table_id:  identifier of the schedule table.
 *
 * Return value:
 * E_OK:       No error.
 * E_OS_ID:    Invalid schedule table id, or the schedule table is not
 *     configured as explicitly synchronized.
 */
FUNC(StatusType, OS_CODE) SetScheduleTableAsync(CONST(ScheduleTableType, AUTOMATIC) sched_table_id)
{
  
  slow_task( (void*) &sched_table_id,NULL,NULL,OSServiceId_SetScheduleTableAsync);

  StatusType res = tpl_set_schedule_table_async_service(sched_table_id);

  compute_NEFT( (void*) &sched_table_id,NULL,NULL,OSServiceId_SetScheduleTableAsync);
  
  
  return res;
  
}


/* End of file tpl_os.c */
